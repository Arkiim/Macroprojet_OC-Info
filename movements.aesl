<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="34294" name="thymio-II">#Partie Variables

var a = 1000 # valeur pour timer principal qui sert de boucle et aussi définit pendant combien de temps thymio avance ou recule

var t = 2300 # valeur pour timer où thymio tourne

var w = 100 # valeur pour timer permettant de faire attendre entre plusieurs instructions consécutives

var mf = 150 # vitesse lorsque le thymio avance (Moove Forward)

var mt = 200 # vitesse lorsque le thymio tourne (Moove Turn)

var turn = 0 # variable "flag" pour pouvoir avancer après un virage

var c[] = [4,4,3,1,1,0] #tableau d'instruction de mouvement. Tout droit: c[i] = 1, droite: c[i]=2,  gauche: c[i]=3, reculer c[i] = 4.

var i # var définissant la position de l'i-ème élément du tableau C

var Mode = 0 #Variable définissant le "mode d'interprétation" du code pour thymio. Si Mode = 0 Thymio lira les valeurs et si Mode = 1 Thymio initiera les timers pour s'occuper du mouvement. avec entre les 2 des temps d'arrêt pour laisser le temps a Thymio de bouger avant de lire la prochaine valeur du tableau.

#*____________
Partie Timers *#
i = 0
timer.period[0] = a #Démarre directement la boucle "endless" qui tournera tournera tout le temps répétant le test "sur quel mode est Thymio?" , ceci sera remplacer plus tard par la commande "Centre" de la telecommande * 

onevent timer0

	if Mode == 1 then #Thymio bouge

		if turn == 0  # si le flag pour tourner (turn) est nul , il arrête le mouvement sinon active le 2nd timer, pour avancer d'une case 
		then
			timer.period[0] = 0
			timer.period[1] = w # timer servant à faire attendre le programme pour qu'il n'exécute pas tout de suite le "if Mode == 0" et n'exécute pas tout en même temps )
			motor.left.target = 0
			motor.right.target = 0
			i++ #incrémente de 1, pour la prochaine "itération" du timer0
		
		elseif turn == 1 # S'il a tourné, avance d'une case
		then
			timer.period[0] = 0
			timer.period[1]= a
			motor.left.target = mf
			motor.right.target = mf
		end
	end
#*____________
Partie test valeurs tableau *#
	
	if Mode == 0 #Thymio lit les valeurs (il est en deuxième pour éviter que il saute des valeurs lorsque il reprend la boucle)
	then
	
		if c[i] == 1 
		then
			callsub moove #fonction mettant la periode de Timer0 a 1 seconde et faisant avancer Thymio pendant toute la période de Timer0 
			
			Mode = 1 #change de mode, ce qui enclenche la 1ère itération des timers. (qui elle s'occupe de la partie mouvement  avec "if Mode=1"). Ils arrêtent le mouvement et avec timer1 (plus bas) marquent un temps d'arrêt, reprennent la boucle et remettent le Mode à 0 
			
		# Impossible de mettre i++ car conflit
		
		elseif c[i] == 2 
		then
			callsub tright #idem pour moove mais a droite 
			Mode = 1
			i++
		
		elseif c[i] == 3
		then
			callsub tleft #idem a gauche
			Mode = 1 
			i++ 
		
		elseif c[i] == 4 #idem derrière
		then
			callsub back
			Mode = 1
			
		else
			return # si la i-ième case du tableau contient autre chose que 1,2,3 ou 4 arrête d'incrémenter, sort de la "boucle" et arrête le test
		end	
	
	end

onevent timer1 #arrête timer0 et timer1 et remet le Mode = 0

	timer.period[1] = 0
	timer.period[0] = a # Redemarre la boucle
	motor.left.target = 0
	motor.right.target = 0
	turn = 0
	Mode = 0

#*_____
Partie mouvement*#

sub moove # fait avancer le thymio d'une case
	timer.period[0]= a
	motor.left.target = mf
	motor.right.target = mf
	turn = 0

sub tright # fait tourner le thymio a droite puis "active" turn
	timer.period[0] = t
	motor.left.target = mt
	motor.right.target = 0
	turn = 1	
	
	
sub tleft # fait tourner le thymio a gauche
	timer.period[0] = t
	motor.left.target = 0
	motor.right.target = mt
	turn = 1
	
sub back #fait reculer le thymio
	timer.period[0] = a
	motor.left.target = -mt
	motor.right.target = -mt
	turn = 0		

</node>


</network>
