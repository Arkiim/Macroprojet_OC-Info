<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<event size="5" name="motors"/>


<!--list of constants-->
<constant value="100" name="SIGMA"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="34294" name="thymio-II">#Partie Variables

var speed
#var target_speed
var left
var right
# mean and vari(ance) calculation vars
var mini
var maxi
var mean
var vari
# actual value and n(ormalized)dev(iation)
var p1
var ndev
# pi controller vars
var ireg
var preg
var pcoeff
var icoeff




var a = 1000 # valeur pour timer principal qui sert de boucle et aussi définit pendant combien de temps thymio avance ou recule

var t = 2300 # valeur pour timer où thymio tourne

var w = 100 # valeur pour timer permettant de faire attendre entre plusieurs instructions consécutives

var mf = 150 # vitesse lorsque le thymio avance (Moove Forward)

var mt = 200 # vitesse lorsque le thymio tourne (Moove Turn)

var turn = 0 # variable "flag" pour pouvoir avancer après un virage

var c[] = [0,0,0,0,0,0,0,0,0,0,0,0] #tableau d'instruction de mouvement. Tout droit: c[i] = 1, droite: c[i]=2,  gauche: c[i]=3, reculer c[i] = 4.

var i = 0 # var définissant la position de l'i-ème élément du tableau C

var n = 0 # var (utilisé lors de la création du tableau, 2 vars différentes pour éviter les conflit avec i) définissant la position de l'n-ème élément du tableau C

var rc # var permettant de stocker la valeur de "rc5.command" pour pouvoir la comparer plus tard

var Mode = 10 #Variable définissant le "mode d'interprétation" du code pour thymio. Si Mode = 0 Thymio lira les valeurs et si Mode = 1 Thymio initiera les timers pour s'occuper du mouvement. avec entre les 2 des temps d'arrêt pour laisser le temps a Thymio de bouger avant de lire la prochaine valeur du tableau.

timer.period[0] = 50
#onevent startup
  speed=150
  #
  mini=1024
  maxi=0
  mean=512
  vari=512
  #
  pcoeff=60
  icoeff=33
  ireg=0
#*____________
Partie telecommande *#  
onevent rc5

#Partie "création" (met les valeurs des flèches entrées dans le tableau) Dans la déclaration "if Mode == 10" du onevent timer0 plus bas


#Partie "GO/STOP" (Faire bouger avec les boutons)

if rc5.command == 53 #boutton go
then
		Mode = 0 #met mode qui prépare à lire le tableau
		timer.period[0] = a #enclenche la boucle grâce au 1er timer
		rc5.command = 0
end

if rc5.command == 87 #boutton "stop"
then
	Mode = 2	# met le mode prévu pour les dernières entrées ou arrêts
	rc5.command = 0
end

#*____________
Partie Principale Timers *#

onevent timer0

	if Mode == 10 # (Partie création du tableau) Mode où les valeurs rc5 des entrées sur la télécommande sont mises dans le tableau c[]
	then
		rc = rc5.command #stock la valeur de la touche entrée pour pouvoir la comparer après
		rc5.command = 0 #remet à 0 pour que le code marche si on veut appuier deux fois sur la même touche
		
		if rc == 80 
		then
			c[n] = 1
		
		elseif rc == 86 
		then
			c[n] = 2
	
		elseif rc == 85					
		then
			c[n] = 3
		
		elseif rc == 81 
		then
			c[n] = 4
		
		elseif rc == 0 # si jamais il y a un problème qui necessite de remettre des valeurs à 0
		then
			c[n] = 0	
			
		elseif rc == 5 #5 pour fermer le tableau. Chaque combinaison de directions devra toujours être terminé par un 5 pour clore le tableau et empêcher toute modification involontaire
		then
			c[n] = 5
			timer.period[0] = 0
			return
	end
	
	if rc5.command != rc 
	# compare l'ancienne valeur de rc5 commande avec la nouvelle pour empêcher le while d'incrémenter n et de continuer la prochaine étape, tant que l'utilisateur n'as pas appuyé sur une autre touche de la télécommande.$
	then
		n++	
	end	
				
	elseif Mode == 1 #Thymio bouge
	then	
	
		if turn == 0  # si le flag pour tourner (turn) est nul , il arrête le mouvement sinon active le 2nd timer, pour avancer d'une case (s'il a fait un virage)
		then
			timer.period[0] = 0
			timer.period[1] = w # timer servant à faire attendre le programme pour qu'il n'exécute pas tout de suite le "if Mode == 0" et n'exécute pas tout en même temps )
			motor.left.target = 0
			motor.right.target = 0
			i++ #incrémente de 1, pour la prochaine "itération" du timer0
		
		elseif turn == 1 # S'il a tourné, avance d'une case
		then
			timer.period[0] = 0
			timer.period[1]= a
			motor.left.target = mf
			motor.right.target = mf
		end
		
	elseif Mode == 2 #COMMENTAURE SUR MODE 2 A FAIRE + COMMENT TVCOMMANDE
	then
		i = 0
		if turn == 0
		then
			timer.period[0] = 0
			timer.period[1] = 0 
			motor.left.target = 0
			motor.right.target = 0
		
		elseif turn == 1
		then
			timer.period[0] = 0
			timer.period[1]= a
			motor.left.target = mf
			motor.right.target = mf
		end
		
	end
	
#*____________
Partie test valeurs tableau *#
	
	if Mode == 0 #(Mode par défaut) Thymio lit les valeurs (partie de code mise à la fin pour éviter qu'il saute des valeurs lorsque il reprend la boucle)
	then
	
		#*if c[i] == 5 #
		then 
			Mode = 2 #MOde 2 sert pour dernière val du tableau incrémente pas arrête timer et sert aussi a pouvoir lancer l'execution du tableau 2 fois en remettant i=0 etc...
			return
		end*#
			
		if c[i] == 1 
		then
			callsub moove #fonction mettant la periode de Timer0 a 1 seconde et faisant avancer Thymio pendant toute la période de Timer0 
			
			Mode = 1 #change de mode, ce qui enclenche la 1ère itération des timers. (qui elle s'occupe de la partie mouvement  avec "if Mode=1"). Ils arrêtent le mouvement et avec timer1 (plus bas) marquent un temps d'arrêt, reprennent la boucle et remettent le Mode à 0 
			
		# Impossible de mettre i++ car conflit
		
		elseif c[i] == 2 
		then
			callsub tright #idem pour moove mais a droite 
			Mode = 1
			i++
		
		elseif c[i] == 3
		then
			callsub tleft #idem a gauche
			Mode = 1 
			i++ 
		
		elseif c[i] == 4 #idem derrière
		then
			callsub back
			Mode = 1
			
		elseif c[i] == 5 
		then
			Mode = 2
			return	
			
		else
 			return # si la i-ième case du tableau contient autre chose que 1,2,3 ou 4 arrête d'incrémenter, sort de la "boucle" et arrête le test
		end	
	
	end

onevent timer1 #arrête timer0 et timer1 et remet le Mode = 0
if Mode == 2 then
	timer.period[1] = 0
	timer.period[0] = 0 # Redemarre la boucle
	motor.left.target = 0
	motor.right.target = 0
	turn = 0
	Mode = 0
else
	timer.period[1] = 0
	timer.period[0] = a # Redemarre la boucle
	motor.left.target = 0
	motor.right.target = 0
	turn = 0
	Mode = 0
end
#*_____
Partie mouvement*#


sub statistics
  call math.max(maxi,maxi,p1)			  # find max p1 -> maxi
  call math.min(mini,mini,p1)             # find min p1 -> mini
  if maxi-mini>400 then
  	call math.muldiv(vari,45,maxi-mini,100) 
    mean=(mini+maxi)/2
  end


sub set_motor
  emit motors [-100,100,0,ireg,ndev]
  motor.left.target=left
  motor.right.target=right




sub moove # fait avancer le thymio d'une case
	timer.period[0]= a
	motor.left.target = mf
	motor.right.target = mf
	turn = 0
	
	#*Partie suit ligne noir *#
	onevent prox
	p1=prox.ground.delta[1]                
  callsub statistics
  call math.muldiv(ndev,SIGMA,p1-mean,vari)
  if abs(ndev)&lt;2*SIGMA then				   # Am I still on the edge?
    call leds.top(0,0,0)
    # pi controller
    preg=(pcoeff*ndev)/100
    ireg+=(icoeff*preg)/100
    # calc speed of motors 	
    left=speed+(preg+ireg)
    right=speed-(preg+ireg)
  else                                    # I'm outside, help!
    call leds.top(32,0,0)
    ireg=0
    left=ndev
    right=-ndev
  end
  #pc+=1
  callsub set_motor
	#fin

sub tright # fait tourner le thymio a droite puis "active" turn
	timer.period[0] = t
	motor.left.target = mt
	motor.right.target = 0
	turn = 1	


	p1=prox.ground.delta[1]                
  callsub statistics
  call math.muldiv(ndev,SIGMA,p1-mean,vari)
  if abs(ndev)&lt;2*SIGMA then				   # Am I still on the edge?
    call leds.top(0,0,0)
    # pi controller
    preg=(pcoeff*ndev)/100
    ireg+=(icoeff*preg)/100
    # calc speed of motors 	
    left=speed+(preg+ireg)
    right=speed-(preg+ireg)
  else                                    # I'm outside, help!
    call leds.top(32,0,0)
    ireg=0
    left=ndev
    right=-ndev
  end
  #pc+=1
  callsub set_motor
	#fin
	
sub tleft # fait tourner le thymio a gauche
	timer.period[0] = t
	motor.left.target = 0
	motor.right.target = mt
	turn = 1
	

	p1=prox.ground.delta[1]                
  callsub statistics
  call math.muldiv(ndev,SIGMA,p1-mean,vari)
  if abs(ndev)&lt;2*SIGMA then				   # Am I still on the edge?
    call leds.top(0,0,0)
    # pi controller
    preg=(pcoeff*ndev)/100
    ireg+=(icoeff*preg)/100
    # calc speed of motors 	
    left=speed+(preg+ireg)
    right=speed-(preg+ireg)
  else                                    # I'm outside, help!
    call leds.top(32,0,0)
    ireg=0
    left=ndev
    right=-ndev
  end
  #pc+=1
  callsub set_motor
	#fin
	
	
	
sub back #fait reculer le thymio
	timer.period[0] = a
	motor.left.target = -mt
	motor.right.target = -mt
	turn = 0		



	p1=prox.ground.delta[1]                
  callsub statistics
  call math.muldiv(ndev,SIGMA,p1-mean,vari)
  if abs(ndev)&lt;2*SIGMA then				   # Am I still on the edge?
    call leds.top(0,0,0)
    # pi controller
    preg=(pcoeff*ndev)/100
    ireg+=(icoeff*preg)/100
    # calc speed of motors 	
    left=speed+(preg+ireg)
    right=speed-(preg+ireg)
  else                                    # I'm outside, help!
    call leds.top(32,0,0)
    ireg=0
    left=ndev
    right=-ndev
  end
  #pc+=1
  callsub set_motor
	#fin
</node>


</network>
